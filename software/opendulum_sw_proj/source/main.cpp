/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */


#include <stdint.h>
#include <math.h>
#include "stm32g4xx.h"

#include "stm32g4xx_hal.h"

#include "stm32g4xx_ll_rcc.h"
#include "stm32g4xx_ll_bus.h"
#include "stm32g4xx_ll_crs.h"
#include "stm32g4xx_ll_system.h"
#include "stm32g4xx_ll_exti.h"
#include "stm32g4xx_ll_cortex.h"
#include "stm32g4xx_ll_utils.h"
#include "stm32g4xx_ll_pwr.h"
#include "stm32g4xx_ll_dma.h"
#include "stm32g4xx_ll_gpio.h"
#include "stm32g4xx_hal_rcc.h"
#include "stm32g4xx_hal_flash.h"
#include "system_stm32g4xx.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


#define RCC_ERROR_NONE 0
#define RCC_ERROR_TIMEOUT 1


__IO uint8_t startup_status = 0;



//static void MX_GPIO_Init(void);

void     LED_Blinking(uint32_t Period);





int main(void)
{
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
  __HAL_FLASH_DATA_CACHE_ENABLE();

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_SYSCFG);
  LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);


  /* System interrupt init*/
  NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);


  /** Disable the internal Pull-Up in Dead Battery pins of UCPD peripheral */
  LL_PWR_DisableUCPDDeadBattery();

#if 0
  LL_FLASH_SetLatency(LL_FLASH_LATENCY_0);
  while(LL_FLASH_GetLatency() != LL_FLASH_LATENCY_0)
  {
  }
  LL_PWR_SetRegulVoltageScaling(LL_PWR_REGU_VOLTAGE_SCALE1);
  LL_RCC_HSI_Enable();
   /* Wait till HSI is ready */
  while(LL_RCC_HSI_IsReady() != 1)
  {
  }

  LL_RCC_HSI_SetCalibTrimming(64);
  LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_HSI);
   /* Wait till System clock is ready */
  while(LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_HSI)
  {
  }

  /* Set AHB prescaler*/
  LL_RCC_SetAHBPrescaler(LL_RCC_SYSCLK_DIV_1);
  LL_RCC_SetAPB1Prescaler(LL_RCC_APB1_DIV_1);
  LL_RCC_SetAPB2Prescaler(LL_RCC_APB2_DIV_1);

  LL_Init1msTick(16000000);

  LL_SetSystemCoreClock(16000000);
#endif 


  /** NOTE: as per TRM section 7.4.3 RCC_CFGR, default value of HPRE is 0, and 
   * as per TRM section 6.1.5, you must set AHB clock divider by 2 before setting
   * the higher frequency.  Must add that here, before switching over to PLL/Boost mode. */





  /** This sets a HAL variable used by other functions in the HAL library,
   * such as the default function for "HAL_InitTick," 
   * SPI timeout checks or ADC initialization wait loops. 
   * 
   * At this point, the SYSCLK is running off of the 16MHz HSI,
   * so set the HAL variable that tracks HCLK accordingly:*/
  LL_SetSystemCoreClock(HSI_VALUE);

  
  /** We are using the default, weak version of the HAL's SysTick
   * implementation that triggers an interrupt via SysTick. This prevents
   * an infinite while loop from occurring if the HSE or PLL fail to stabilize. 
   * 
   * More info on the ARM SysTick can be found here: 
   * https://developer.arm.com/documentation/101407/0542/Debugging/Debug-Windows-and-Dialogs/Core-Peripherals/Armv7-M-cores/Armv7-M--System-Tick-Timer */
  if (HAL_InitTick(0) != HAL_OK)
  {
    startup_status |= HAL_ERROR;
  }
  
  
  /** Configure the main internal regulator output voltage */
  HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1_BOOST);



  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
  
  /** Since there is no crystal resonator or high precision clock source
   * for the moteus c1 (the HW i'm testing on) just initialize the LSI 
   * for the IWDG. */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI;// | RCC_OSCILLATORTYPE_HSE;
  //RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.HSEState = RCC_HSE_OFF;

  /** As per TRM Section 7.4.4, 
   *   - f(VCO_clock) = f(PLL_clock_input) * (PLLN / PLLM)
   *   - f(PLL_x) = f(VCO_clock) / PLLx    (where x = P, Q and R)
   * 
   * As per STM32G474xx datasheet (DS12288 Rev 6) section 5.3.9, 
   * the maximum PLL VCO frequency is 344MHz while in voltage scaling 
   * range 1. 
   * 
   * The intended SYSCLK frequency is 170MHz, which is the maximum
   * that this device can support.  HSI freq = 16MHz, 
   * N = 85, M = 4, VCO = 340MHz, P, Q and R CLK's = 170MHz
   * 
   */
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLN = 85;
  RCC_OscInitStruct.PLL.PLLM = RCC_PLLM_DIV4;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; //RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    startup_status |= HAL_ERROR;
  }

  /** Initializes the CPU, AHB and APB buses clocks. */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  /** TRM section 4.3.3 (or 3.3.3 or 5.3.3), for max frequency we need 4 wait states, or 5 cpu 
   * cycles for flash access latency. */
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
  {
    startup_status |= HAL_ERROR;
  }


  //MX_GPIO_Init();


  while (1)
  {

  }
}



#if 0
static void MX_GPIO_Init(void)
{
  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  LL_AHB2_GRP1_EnableClock(LL_AHB2_GRP1_PERIPH_GPIOA);

  /**/
  LL_GPIO_ResetOutputPin(LED2_GPIO_Port, LED2_Pin);

  /**/
  GPIO_InitStruct.Pin = LED2_Pin;
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
  LL_GPIO_Init(LED2_GPIO_Port, &GPIO_InitStruct);
}



void LED_Blinking(uint32_t Period)
{
  /* Turn LED2 on */
  LL_GPIO_SetOutputPin(LED2_GPIO_Port, LED2_Pin);

  /* Toggle IO in an infinite loop */
  while (1)
  {
    /* Error if LED2 is slowly blinking (1 sec. period) */
    LL_GPIO_TogglePin(LED2_GPIO_Port, LED2_Pin);
    LL_mDelay(Period);
  }
}
#endif



/******************************************************************************/
/*   USER IRQ HANDLER TREATMENT                                               */
/******************************************************************************/

extern "C" void SysTick_Handler(void)
{
  HAL_IncTick();
}
